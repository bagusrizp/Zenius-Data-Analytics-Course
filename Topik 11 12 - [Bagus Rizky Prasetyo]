{"cells":[{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true,"base_uri":"https://localhost:8080/","height":0},"id":"__wfaiUVecdX"},"outputs":[{"data":{"text/html":["\n","     \u003cinput type=\"file\" id=\"files-8b85d633-c547-4204-85b5-3fc79f144f05\" name=\"files[]\" multiple disabled\n","        style=\"border:none\" /\u003e\n","     \u003coutput id=\"result-8b85d633-c547-4204-85b5-3fc79f144f05\"\u003e\n","      Upload widget is only available when the cell has been executed in the\n","      current browser session. Please rerun this cell to enable.\n","      \u003c/output\u003e\n","      \u003cscript\u003e// Copyright 2017 Google LLC\n","//\n","// Licensed under the Apache License, Version 2.0 (the \"License\");\n","// you may not use this file except in compliance with the License.\n","// You may obtain a copy of the License at\n","//\n","//      http://www.apache.org/licenses/LICENSE-2.0\n","//\n","// Unless required by applicable law or agreed to in writing, software\n","// distributed under the License is distributed on an \"AS IS\" BASIS,\n","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n","// See the License for the specific language governing permissions and\n","// limitations under the License.\n","\n","/**\n"," * @fileoverview Helpers for google.colab Python module.\n"," */\n","(function(scope) {\n","function span(text, styleAttributes = {}) {\n","  const element = document.createElement('span');\n","  element.textContent = text;\n","  for (const key of Object.keys(styleAttributes)) {\n","    element.style[key] = styleAttributes[key];\n","  }\n","  return element;\n","}\n","\n","// Max number of bytes which will be uploaded at a time.\n","const MAX_PAYLOAD_SIZE = 100 * 1024;\n","\n","function _uploadFiles(inputId, outputId) {\n","  const steps = uploadFilesStep(inputId, outputId);\n","  const outputElement = document.getElementById(outputId);\n","  // Cache steps on the outputElement to make it available for the next call\n","  // to uploadFilesContinue from Python.\n","  outputElement.steps = steps;\n","\n","  return _uploadFilesContinue(outputId);\n","}\n","\n","// This is roughly an async generator (not supported in the browser yet),\n","// where there are multiple asynchronous steps and the Python side is going\n","// to poll for completion of each step.\n","// This uses a Promise to block the python side on completion of each step,\n","// then passes the result of the previous step as the input to the next step.\n","function _uploadFilesContinue(outputId) {\n","  const outputElement = document.getElementById(outputId);\n","  const steps = outputElement.steps;\n","\n","  const next = steps.next(outputElement.lastPromiseValue);\n","  return Promise.resolve(next.value.promise).then((value) =\u003e {\n","    // Cache the last promise value to make it available to the next\n","    // step of the generator.\n","    outputElement.lastPromiseValue = value;\n","    return next.value.response;\n","  });\n","}\n","\n","/**\n"," * Generator function which is called between each async step of the upload\n"," * process.\n"," * @param {string} inputId Element ID of the input file picker element.\n"," * @param {string} outputId Element ID of the output display.\n"," * @return {!Iterable\u003c!Object\u003e} Iterable of next steps.\n"," */\n","function* uploadFilesStep(inputId, outputId) {\n","  const inputElement = document.getElementById(inputId);\n","  inputElement.disabled = false;\n","\n","  const outputElement = document.getElementById(outputId);\n","  outputElement.innerHTML = '';\n","\n","  const pickedPromise = new Promise((resolve) =\u003e {\n","    inputElement.addEventListener('change', (e) =\u003e {\n","      resolve(e.target.files);\n","    });\n","  });\n","\n","  const cancel = document.createElement('button');\n","  inputElement.parentElement.appendChild(cancel);\n","  cancel.textContent = 'Cancel upload';\n","  const cancelPromise = new Promise((resolve) =\u003e {\n","    cancel.onclick = () =\u003e {\n","      resolve(null);\n","    };\n","  });\n","\n","  // Wait for the user to pick the files.\n","  const files = yield {\n","    promise: Promise.race([pickedPromise, cancelPromise]),\n","    response: {\n","      action: 'starting',\n","    }\n","  };\n","\n","  cancel.remove();\n","\n","  // Disable the input element since further picks are not allowed.\n","  inputElement.disabled = true;\n","\n","  if (!files) {\n","    return {\n","      response: {\n","        action: 'complete',\n","      }\n","    };\n","  }\n","\n","  for (const file of files) {\n","    const li = document.createElement('li');\n","    li.append(span(file.name, {fontWeight: 'bold'}));\n","    li.append(span(\n","        `(${file.type || 'n/a'}) - ${file.size} bytes, ` +\n","        `last modified: ${\n","            file.lastModifiedDate ? file.lastModifiedDate.toLocaleDateString() :\n","                                    'n/a'} - `));\n","    const percent = span('0% done');\n","    li.appendChild(percent);\n","\n","    outputElement.appendChild(li);\n","\n","    const fileDataPromise = new Promise((resolve) =\u003e {\n","      const reader = new FileReader();\n","      reader.onload = (e) =\u003e {\n","        resolve(e.target.result);\n","      };\n","      reader.readAsArrayBuffer(file);\n","    });\n","    // Wait for the data to be ready.\n","    let fileData = yield {\n","      promise: fileDataPromise,\n","      response: {\n","        action: 'continue',\n","      }\n","    };\n","\n","    // Use a chunked sending to avoid message size limits. See b/62115660.\n","    let position = 0;\n","    do {\n","      const length = Math.min(fileData.byteLength - position, MAX_PAYLOAD_SIZE);\n","      const chunk = new Uint8Array(fileData, position, length);\n","      position += length;\n","\n","      const base64 = btoa(String.fromCharCode.apply(null, chunk));\n","      yield {\n","        response: {\n","          action: 'append',\n","          file: file.name,\n","          data: base64,\n","        },\n","      };\n","\n","      let percentDone = fileData.byteLength === 0 ?\n","          100 :\n","          Math.round((position / fileData.byteLength) * 100);\n","      percent.textContent = `${percentDone}% done`;\n","\n","    } while (position \u003c fileData.byteLength);\n","  }\n","\n","  // All done.\n","  yield {\n","    response: {\n","      action: 'complete',\n","    }\n","  };\n","}\n","\n","scope.google = scope.google || {};\n","scope.google.colab = scope.google.colab || {};\n","scope.google.colab._files = {\n","  _uploadFiles,\n","  _uploadFilesContinue,\n","};\n","})(self);\n","\u003c/script\u003e "],"text/plain":["\u003cIPython.core.display.HTML object\u003e"]},"metadata":{},"output_type":"display_data"},{"ename":"TypeError","evalue":"ignored","output_type":"error","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)","\u001b[0;32m\u003cipython-input-1-76726763abe8\u003e\u001b[0m in \u001b[0;36m\u003cmodule\u003e\u001b[0;34m\u001b[0m\n\u001b[1;32m     12\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mmatplotlib\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpyplot\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mplt\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     13\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---\u003e 14\u001b[0;31m \u001b[0muploaded\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mfiles\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mupload\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     15\u001b[0m \u001b[0mdf\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mpd\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread_csv\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mio\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mBytesIO\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0muploaded\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'dataset.csv'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     16\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.7/dist-packages/google/colab/files.py\u001b[0m in \u001b[0;36mupload\u001b[0;34m()\u001b[0m\n\u001b[1;32m     65\u001b[0m   \"\"\"\n\u001b[1;32m     66\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---\u003e 67\u001b[0;31m   \u001b[0muploaded_files\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_upload_files\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmultiple\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mTrue\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     68\u001b[0m   \u001b[0;31m# Mapping from original filename to filename as saved locally.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     69\u001b[0m   \u001b[0mlocal_filenames\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdict\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.7/dist-packages/google/colab/files.py\u001b[0m in \u001b[0;36m_upload_files\u001b[0;34m(multiple)\u001b[0m\n\u001b[1;32m    147\u001b[0m   \u001b[0mfiles\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_collections\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdefaultdict\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbytes\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    148\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--\u003e 149\u001b[0;31m   \u001b[0;32mwhile\u001b[0m \u001b[0mresult\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'action'\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m!=\u001b[0m \u001b[0;34m'complete'\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    150\u001b[0m     result = _output.eval_js(\n\u001b[1;32m    151\u001b[0m         'google.colab._files._uploadFilesContinue(\"{output_id}\")'.format(\n","\u001b[0;31mTypeError\u001b[0m: 'NoneType' object is not subscriptable"]}],"source":["#Untuk mengupload file\n","from google.colab import files\n","\n","#Untuk membaca file\n","import io\n","\n","#Untuk mengimport file\n","import pandas as pd\n","\n","#Untuk visualisasi\n","import seaborn as sns\n","import matplotlib.pyplot as plt\n","\n","uploaded = files.upload()\n","df = pd.read_csv(io.BytesIO(uploaded['dataset.csv']))\n","\n","#Praktik kali ini mencoba upload file dengan cara yang sedikit berbeda, yaitu\n","#dengan menggunakan 'io' dan 'files'. Dataset yang akan digunakan diupload,\n","#kemudian dibaca dengan library 'pandas'. "]},{"cell_type":"markdown","metadata":{"id":"sDCgHgK4b_7P"},"source":["# Data Understanding"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"VT53Z_0qfj0c"},"outputs":[],"source":["#Menampilkan 5 kolom teratas dengan menggunakan 'head'. Hal ini dilakukan untuk\n","#memahami data.\n","\n","df.head()"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"1Vx48y_tPz3p"},"outputs":[],"source":["#Gunakan fungsi 'shape' untuk melihat dimensi data. Dataset yang digunakan\n","#memiliki 7043 baris dan 21 kolom/atribut.\n","\n","df.shape"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"WXW-8yaMgCG3"},"outputs":[],"source":["#Gunakan fungsi 'columns' untuk melihat nama kolom yang digunakan pada data.\n","#Hal ini dilakukan sebagai salah satu langkah untuk memahami data yang\n","#digunakan.\n","\n","df.columns"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"hZ3YhrKTgZEc"},"outputs":[],"source":["#Gunakan fungsi 'info' untuk melihat tipe data masing-masing kolom dan juga\n","#value non-null yang terdapat pada data. Terdapat keanehan pada atribut\n","#'TotalCharges' yang teridentifikasi sebagai object, padahal data tersebut \n","#seharusnya bertipe numerik apabila dilihat dari isi valuenya pada baris [2].\n","\n","df.info()"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"6UbSQnKFQv0K"},"outputs":[],"source":["#Gunakan fungsi 'describe' untuk memberikan pemahaman pada data numerik. Pada\n","#bagian ini dapat dilihat bahwa atribut 'SeniorCitizen' memiliki nilai minimal\n","#0 dan maksimal 1. Terdapat indikasi bahwa data ini bertipe kategorikal.\n","\n","df.describe()"]},{"cell_type":"markdown","metadata":{"id":"SDnSVWi6dUnd"},"source":["# Data Cleaning"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"wS5Wgya3g4mF"},"outputs":[],"source":["#Gunakan fungsi 'to_numeric' pada library pandas untuk mengubah atribut 'Total\n","#Charges' menjadi numerik. Isikan 'coerce' pada parameter errors untuk mengubah\n","#value yang tidak bisa dikonversi menjadi null.\n","\n","df['TotalCharges'] = pd.to_numeric(df['TotalCharges'],errors=\"coerce\")"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"KhIY5cSQjb04"},"outputs":[],"source":["#Gunakan fungsi 'astype('object')' pada library pandas untuk mengubah atribut\n","#'SeniorCitizen' dari data numerik menjadi data kategorikal. Lalu gunakan fungsi\n","#'dtypes' untuk memeriksa apakah tipe data telah berubah. Dapat dilihat bahwa\n","#'SeniorCitizen' telah berubah menjadi object.\n","\n","df['SeniorCitizen']=df['SeniorCitizen'].astype('object')\n","df.dtypes"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"pCVBOT-Sh1Y_"},"outputs":[],"source":["#Gunakan fungsi 'isnull().sum()' untuk melihat jumlah null yang terdapat pada\n","#dataset setelah dilakukan pengubahan jenis tipe data. Dapat terlihat pada\n","#atribut 'TotalCharges' bahwa terdapat 11 null yang muncul.\n","\n","df.isnull().sum()"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"4E8O3O6uiFBK"},"outputs":[],"source":["#Memeriksa baris yang berisikan nilai null dengan menggunakan fungsi 'isna()'\n","\n","df[df['TotalCharges'].isna()]"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"5YGS5bw-aW9H"},"outputs":[],"source":["#Hapus nilai null yang terdapat pada kolom dengan fungsi 'dropna()'. Fungsi\n","#ini akan menghapus keseluruhan baris yang memiliki nilai null. Setelah itu,\n","#lakukan pengecekan dengan fungsi 'isnull().sum(). Metode penghapusan digunakan\n","#karena tidak terdapat informasi yang mendukung untuk mengisi null dengan value\n","#lain, sehingga untuk saat ini dianggap yang paling aman.\n","\n","df = df.dropna()\n","df.isnull().sum()"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"MgI61_YQie_N"},"outputs":[],"source":["#Gunakan kode dibawah untuk menghapus kolom 'customerID'. Penghapusan dilakukan\n","#untuk meringkas dataset agar lebih mudah dilakukan analisa nantinya. Atribut\n","#'customerID' tidak memiliki pengaruh yang signifikan untuk pencarian insight\n","#pada data nantinya.\n","\n","df = df.drop(columns=['customerID'])"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"j4GLsx4Li6cD"},"outputs":[],"source":["#Gunakan fungsi 'describe' sekali lagi untuk melihat statistik dari data\n","#numerikal yang terdapat pada dataset setelah dilakukan proses cleaning.\n","\n","df.describe()\n"]},{"cell_type":"markdown","metadata":{"id":"Z-GYCc64oj14"},"source":["# Data Visualizing"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"6736VIoWkDCe"},"outputs":[],"source":["#Gunakan countplot untuk memvisualisasikan jumlah value dalam suatu atribut\n","#kategorikal. Pada kali ini atribut 'Churn' akan digunakan untuk melihat jumlah\n","#value yes dan no didalamnya. Dapat dilihat bahwa jumlah 'no' jauh lebih banyak\n","#daripada 'yes'.\n","\n","#Import library seaborn\n","import seaborn as sns\n","\n","#Tampilkan diagram\n","sns.countplot(data=df,x=\"Churn\")"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"gzvjEQVGkwV2"},"outputs":[],"source":["#Kali ini terdapat penambahan dalam visualisasi plot dengan menambahkan atribut\n","#'Gender' yang digolongkan berdasarkan 'Churn'. Hasilnya dapat dilihat bahwa\n","#tidak terdapat perbedaan yang signifikan antara value 'yes' dan 'no' pada \n","#'male' dan 'female'.\n","\n","sns.countplot(data=df,x=\"gender\",hue=\"Churn\")"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"JknJtm7XlMzd"},"outputs":[],"source":["#Atribut Tenure divisualisasikan berdasarkan atribut Churn. Terdapat outliers\n","#yang terdeteksi pada plot tersebut, tepatnya pada value 'Churn Yes'. Konteks\n","#dari plot ini adalah distribusi pengguna yang memberhentikan penggunaan layanan\n","#dalam sebulan terakhir. Boxplot 'No' menyatakan data yang terdistribusi secara\n","#normal dan hampir simetris. Garis median berada di tengah kotak dengan panjang\n","#whisker yang hampir sama antara atas dan bawah. Boxplot 'Yes' sangat berbeda\n","#karena garis median tidak terletak ditengah kotak. Whisker atas dan bawahpun\n","#berbeda dengan dominan panjang pada bagian atas, serta adanya outliers.\n","#Sehingga, boxplot 'Yes' dapat dikategorikan sebagai positive skewness.  \n","\n","sns.boxplot(data=df,x=\"tenure\",y=\"Churn\")"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"6c6fp-9kl1tD"},"outputs":[],"source":["#Atribut MonthlyCharges divisualisasikan berdasarkan atribut Churn.Konteks\n","#dari plot ini adalah distribusi pengguna yang memberhentikan penggunaan layanan\n","#dalam sebulan terakhir. Boxplot 'No' memperlihatkan data yang tidak\n","#terdistribusi secara normal. Garis median berada lebih dekat dengan kuartil 3 \n","#dengan whisker atas lebih panjang daripada bawah. Sehingga, Boxplot 'No' dapat\n","#dikategorikan sebagai positive skewness. Boxplot 'Yes' berbeda karena garis \n","#median terletak lebih dekat dengan kuartil 3. Whisker atas dan bawahpun\n","#berbeda dengan dominan panjang pada bagian bawah. Sehingga, boxplot 'Yes' dapat\n","#dikategorikan sebagai positive skewness. Kedua boxplot tidak memiliki outliers.  \n","\n","sns.boxplot(data=df,x=\"MonthlyCharges\",y=\"Churn\")"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"XurFvK7wmILK"},"outputs":[],"source":["#Atribut 'TotalCharges' divisualisasikan berdasarkan atribut 'Churn'. Konteks\n","#dari plot ini adalah distribusi total tagihan untuk pengguna yang \n","#memberhentikan penggunaan layanan dalam sebulan terakhir. Boxplot 'No' \n","#memperlihatkan data yang tidak terdistribusi secara normal. Garis median berada\n","#lebih dekat dengan kuartil 1 dengan whisker atas lebih panjang daripada bawah.\n","#Sehingga, Boxplot 'No' dapat dikategorikan sebagai positive skewness.\n","#Boxplot 'Yes' memiliki kemiripan dengan boxplot 'No' karena garis median \n","#terletak lebih dekat dengan kuartil 1. Whisker atas dan bawahpun berbeda dengan\n","#dominan panjang pada bagian atas. Sehingga, boxplot 'Yes' dapat dikategorikan \n","#sebagai positive skewness. Perbedaan pada kedua boxplot adalah ditemukannya\n","#outliers yang cukup banyak pada boxplot 'Yes', sedangkan pada boxplot 'No'\n","#tidak ditemukan adanya outliers.\n","\n","sns.boxplot(data=df,x=\"TotalCharges\",y=\"Churn\")"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"mXL8SE_TmU3S"},"outputs":[],"source":["#Visualisasi countplot untuk atribut 'Contract' dan 'Churn'. Masing-masing jenis\n","#'Contract' akan dibagi berdasarkan value pada 'Churn' untuk diketahui jumlahnya.\n","#Berdasarkan plot tersebut dapat dilihat bahwa value 'No' pada 'Month-to'Month',\n","#'One year Contract' dan 'Two year' mengungguli value 'Yes' disemua variabel yang\n","#sama. Value 'Yes' tertinggi dapat dilihat pada variabel 'Month-to-Month'. Hal\n","#ini dapat mengindikasikan lebih mudah bagi pengguna untuk membatalkan kontrak\n","#pada langganan bulanan daripada tahunan.\n","\n","sns.countplot(data=df,x=\"Contract\",hue=\"Churn\")"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"0KFjy-eBnAPl"},"outputs":[],"source":["#Cek dataset dengan df.head()\n","\n","df.head()"]},{"cell_type":"markdown","metadata":{"id":"XgE0vW1ViEDA"},"source":["# Correlation"]},{"cell_type":"markdown","metadata":{"id":"-U5ZTCdIjRUA"},"source":["\u003e Korelasi membantu kita dalam memahami suatu koneksi dalam sebuah dataset. Misalnya, dalam suatu dataset yang berisikan penjualan mobil disuatu daerah. Mobil dengan kapasitas penumpang lebih besar dan harga yang lebih murah memiliki jumlah pembelian yang lebih tinggi daripada yang lainnya. Sangat penting untuk memastikan bahwa seluruh atribut telah bertipe numerik. Hal ini karena proses korelasi tidak dilakukan pada tipe data kategorikal. Salah satu cara untuk mengubah tipe datanya dilakukan dengan menggunakan encoding."]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"ZI6Ob87HngcU"},"outputs":[],"source":["#Lakukan encoding dengan memanggil fungsi pd.get_dummies(). Konsekuensi dari\n","#jenis encoding ini adalah setiap value dalam atribut kategorikal akan diubah\n","#menjadi atribut. Buat variabel baru bernama df2 dan gunakan df sebagai sumbernya.\n","#Parameter drop_first=True digunakan untuk menghapus level \n","#pertama dalam suatu variabel. Langkah ini dapat dilakukan apabila tidak\n","#menghendaki adanya redudansi variabel.\n","\n","df2 = pd.get_dummies(df,drop_first=True)"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"7cONNb6OotJg"},"outputs":[],"source":["#Buat variabel baru yang bernama df3 untuk menampung hasil korelasi dari df2.\n","#Semakin mendekati 1 maka semakin berkorelasi positif.\n","#Semakin mendekati -1 maka semakin berkorelasi negatif.\n","#Semakin mendekati 0 maka semakin tidak berkorelasi.\n","#Contoh dari adanya korelasi positif adalah apabila suatu variabel semakin\n","#tinggi nilainya, maka variabel yang lain juga akan semakin tinggi. Berlaku\n","#sebaliknya pada korelasi negatif.\n","\n","df3 = df2.corr()['Churn_Yes'].sort_values().reset_index()\n","df3"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"vUCd17YiqFae"},"outputs":[],"source":["#Hapus atribut 'Churn_Yes' untuk melihat korelasi antara 'Churn_Yes' dengan\n","#atribut lainnya.\n","\n","df3=df3[~df3['index'].str.contains('Churn_Yes')]"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"iFtwOlZyqXLi"},"outputs":[],"source":["#Tampilkan hasil korelasi dalam sebuah barplot. \n","\n","chart = sns.barplot(data=df3,x=\"index\",y=\"Churn_Yes\")\n","\n","for item in chart.get_xticklabels():\n","  item.set_rotation(90)"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"q7XBeWUQrNPw"},"outputs":[],"source":["#Gunakan heatmap untuk mengecek korelasi antar atribut secara menyeluruh.\n","\n","fig, ax = plt.subplots(figsize=(20, 20))\n","sns.heatmap(df2.corr(),cmap=\"Blues\", annot=True, ax=ax)\n","plt.show()"]},{"cell_type":"markdown","metadata":{"id":"WyJscziK2euy"},"source":["**Hasil Korelasi**\n","\n","\n","\u003e Berdasarkan korelasi yang dilakukan atas atribut 'Churn', dapat dilihat bahwa tidak terdapat atribut yang memiliki korelasi lebih dari 0,3 dan kurang dari -0,4. Hal ini menunjukan bahwa seluruh atribut memiliki korelasi yang lemah hingga moderat terhadap atribut 'Churn'. Hasil lainnya ditampilkan melalui heatmap. Setelah dilakukan korelasi terhadap keseluruhan atribut dengan heatmap, dapat dilihat bahwa terdapat korelasi yang cukup kuat antara 'InternetService_Fiber optic' dengan 'MonthlyCharges' dengan besar 0,79. Sehingga, dapat diambil hipotesis bahwa penggunaan fiberoptic berpengaruh terhadap biaya langganan perbulan."]}],"metadata":{"colab":{"collapsed_sections":[],"name":"","provenance":[{"file_id":"1VlI3BWXhRJyCiPGl4lNZPTacwjOyLMyM","timestamp":1666854055435}],"version":""},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}